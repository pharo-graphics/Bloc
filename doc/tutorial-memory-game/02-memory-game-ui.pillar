! Building Card Graphical Elements With Bloc Framework

In this chapter, we will build the visual appearance of the cards step by step. In Bloc, visual objects are called elements, which are usually subclasses of ${class:BlElement}$, the inheritance tree root.

!! The Card Element

Our graphic element, called ${class:CardElement}$, representing a card will be a subclass of the ${class:BlElement}$ which has a reference to a card model: ${changes:changes/20-card-element-class.ombu}$
We then define accessor and initialize methods, defining a widget background color and geometry: ${changes:changes/21-card-element-basic-methods.ombu}$The ${method:CardElement>>#initialize|expanded=true}$ method defines the element size, background color, and rounded-rectangle geometry.You can observe the result of the current implementation executing the following snippet:[[[CardElement new]]]!!! Drawing a CardOur card have two sides, back and face that needs to be implemented. We implement them by composing two ${class:BlElement}$ objects, one representing the face side, another the back side.!!!! Back SideLet's start with the back side, that will be represented by two diagonal lines, across the ${class:CardElement}$ card. To do so, we introduce a new ==back== instance variable, that will be initialized in the ${method:CardElement>>#initialize}$: ${changes:changes/22-card-element-back.ombu}$Let's look closer at the ${method:CardElement>>#initializeBack|expanded=true}$ method.We use ${class:BlElement}$ which includes two ${class:BlLineElement}$ objects. Each line element uses two ${class:BlAnchorRelativeToElementBounds}$ subclass objects defining start and end line points. By creating an element instance, we should be able to observe a back side card. To do so, execute the following snippet:[[[CardElement new.]]]!!!! Face SideLet's implement the face side which displays a character (a symbol). We introduce a new ==face== instance variable, that will be initialized in the ${method:CardElement>>#initialize}$: ${changes:changes/23-card-element-face.ombu}$A face-side element, defined in ${method:CardElement>>#initializeFace|expanded=true}$ is a text element, by default hidden and with a ==?== character. It means, that if you execute the following snippet, you will see only the back side as we implemented previously:[[[CardElement new.]]]To be able to see face side, we can implement a method that switch the face- and back- side visibility: ${changes:changes/24-card-element-show-face}$.The ${method:CardElement>>#onFlippedFace|expanded=true}$ shows that every ${class:BlElement}$ defines its visibility using ${class:BlVisibility}$ object. The following snippet should then display the face side, and you will notice that the symbol is not displayed at an expected place yet: [[[CardElement new onFlippedFace.]]]Looking back at the ${method:CardElement>>#initializeFace|expanded=true}$ method (==alignCenter== messages), you can that we defined that the symbol should be in the middle. To fix it we also need to change ${class:CardElement}$'s layout. At this moment it is a ${class:BlBasicLayout}$ as you can check by executing the following snippet:[[[CardElement new layout.]]]${class:BlFrameLayout}$ layout has an ability to center ${class:CardElement}$object's children: ${changes:changes/25-card-element-layout}$Now, the face symbol should be centered: [[[CardElement new onFlippedFace.]]]!!! Updating Element on Card ChangesTu summarize current progress, we have the game model, including ${class:Card}$, ${class:Game}$, and announcements ${class:CardFlipped}$ and ${class:CardDisappeared}$. The UI element ${class:CardElement}$ can display back and face card sides. The UI element does not reflect the model changes as we can check by executing the following snippet:[[[| aCard |aCard := Card new.aCard flip.CardElement new card: aCard.]]]It should display the card's face side. The reason is that the graphical widget does not register to the card model changes in the ${method:CardElement>>#card:|expanded=true}$ method.The following code registers to the card ${class:CardFlipped}$ changes and updates the UI widget accordingly: ${changes:changes/26-card-element-hooks}$The ${class:CardElement}$ now register to ${class:Card}$ changes in the ${method:CardElement>>#card:|expanded=true}$ method:It also triggers an ${method:CardElement>>#onUpdated|expanded=true}$ hook that updates a displayed symbol and a corresponding card side:When ${class:CardFlipped}$ is triggered, a ${method:CardElement>>#onFlipped|expanded=true}$ method is called, which is responsible for displaying the corresponding side:The mechanism to display the back side is implemented in ${method:CardElement>>#onFlippedBack|expanded=true}$, similarly as we did for the face side in ${method:CardElement>>#onFlippedFace}$:To test the existing code, you can execute the following snippet that initialize a card and its element:[[[aCardOne := Card new symbol: $A.aCardOneElement := CardElement new card: aCardOne.]]]To switch card side, execute several times the following snippet and observe the changes in the result above:[[[aCardOne flip.]]]!!! Disappearing Card ElementTo make a card disappear from a game board, we will register to the ${class:CardDisappeared}$ announcement and set the card element's ${class:BlVisibility}$ as we do for the card flipping: ${changes:changes/27-card-element-disappear}$${class:CardElement}$ now registers to ${class:CardDisappeared}$ announcements at ${method:CardElement>>#card:|expanded=true}$:The ${method:CardElement>>#onDisappear|expanded=true}$ is implemented by changing the element visibility:By displaying the card:[[[aCardTwo := Card new symbol: $B.aCardTwoElement := CardElement new card: aCardTwo.]]]we can make it disappear by executing the following snippet:[[[aCardTwo disappear.]]]Notice, that we do not have an ==appear== action as the game does not require it.

!! Ready 

In the next part, we will implement the game board widget: ${inputFile:04-memory-game-board-ui.pillar}$.
